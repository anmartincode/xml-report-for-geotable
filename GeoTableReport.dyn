{
  "Uuid": "28f81a7f-34b7-4cc2-9fb8-ca9ced947277",
  "IsCustomNode": false,
  "Description": "Extract Civil 3D rail alignment geotable data and generate XML reports",
  "Name": "GeoTableReport",
  "ElementResolver": {
    "ResolutionMap": {}
  },
  "Inputs": [],
  "Outputs": [],
  "Nodes": [
    {
      "ConcreteType": "Dynamo.Graph.Nodes.CodeBlockNodeModel, DynamoCore",
      "Id": "21ce6789d9fa4e6ea6760ef79280e26d",
      "NodeType": "CodeBlockNode",
      "Inputs": [],
      "Outputs": [
        {
          "Id": "8a61c5f6c48b4e8aa4360413726249cc",
          "Name": "",
          "Description": "output_path",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        },
        {
          "Id": "858985f70d4246bf98afc7c0924722d5",
          "Name": "",
          "Description": "pretty_print",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        }
      ],
      "Replication": "Disabled",
      "Description": "Allows for DesignScript code to be authored directly",
      "Code": "// XML Output Configuration\n// Leave empty for XML string output, or specify path\noutput_path = \"C:/Users/anmartinez/Downloads/Organized/Code/xml_report.xml\";\n\n// Pretty print formatting\npretty_print = true;"
    },
    {
      "ConcreteType": "PythonNodeModels.PythonNode, PythonNodeModels",
      "Code": "\"\"\"\r\nXML Report Generator for Civil 3D Geotable Data\r\nConverts extracted geotable data into formatted XML reports\r\n\r\nUsage in Dynamo:\r\n- Import as second Python Script node\r\n- Connect output from civil3d_geotable_extractor.py\r\n- Outputs formatted XML string or file\r\n\"\"\"\r\n\r\nimport xml.etree.ElementTree as ET\r\nfrom xml.dom import minidom\r\nimport json\r\nimport sys\r\nfrom datetime import datetime\r\n\r\n\r\nclass XMLReportGenerator:\r\n    \"\"\"Generate XML reports from geotable data\"\"\"\r\n    \r\n    def __init__(self, geotable_data):\r\n        \"\"\"Initialize with geotable data dictionary\"\"\"\r\n        self.data = geotable_data\r\n        self.root = None\r\n        \r\n    def create_xml_structure(self):\r\n        \"\"\"Create the main XML structure\"\"\"\r\n        # Create root element\r\n        self.root = ET.Element('GeotableReport')\r\n        self.root.set('version', '1.0')\r\n        self.root.set('xmlns', 'http://civil3d.autodesk.com/geotable')\r\n        \r\n        # Add project information\r\n        project_info = ET.SubElement(self.root, 'ProjectInfo')\r\n        ET.SubElement(project_info, 'ProjectName').text = self.data.get('project_name', 'Unknown')\r\n        ET.SubElement(project_info, 'GeneratedDate').text = self.data.get('timestamp', \r\n                                                                          datetime.now().strftime('%Y-%m-%d %H:%M:%S'))\r\n        ET.SubElement(project_info, 'ReportType').text = 'Rail Alignment Geotable'\r\n        \r\n        # Add alignments section\r\n        alignments_section = ET.SubElement(self.root, 'Alignments')\r\n        alignments_section.set('count', str(len(self.data.get('alignments', []))))\r\n        \r\n        return alignments_section\r\n    \r\n    def add_alignment_to_xml(self, alignment_data, parent_element):\r\n        \"\"\"Add a single alignment's data to XML\"\"\"\r\n        alignment_elem = ET.SubElement(parent_element, 'Alignment')\r\n        alignment_elem.set('name', alignment_data.get('name', 'Unnamed'))\r\n        alignment_elem.set('id', alignment_data.get('id', ''))\r\n\r\n        # Basic properties\r\n        properties = ET.SubElement(alignment_elem, 'Properties')\r\n        ET.SubElement(properties, 'Description').text = alignment_data.get('description', '')\r\n\r\n        # Add project name if available\r\n        if alignment_data.get('project_name'):\r\n            ET.SubElement(properties, 'ProjectName').text = alignment_data.get('project_name', '')\r\n\r\n        # Add horizontal/vertical alignment names if available\r\n        if alignment_data.get('horizontal_alignment'):\r\n            ET.SubElement(properties, 'HorizontalAlignment').text = alignment_data.get('horizontal_alignment', '')\r\n        if alignment_data.get('vertical_alignment'):\r\n            ET.SubElement(properties, 'VerticalAlignment').text = alignment_data.get('vertical_alignment', '')\r\n        if alignment_data.get('style'):\r\n            ET.SubElement(properties, 'Style').text = alignment_data.get('style', '')\r\n\r\n        ET.SubElement(properties, 'Length').text = str(round(alignment_data.get('length', 0), 3))\r\n        ET.SubElement(properties, 'StartStation').text = str(round(alignment_data.get('start_station', 0), 3))\r\n        ET.SubElement(properties, 'EndStation').text = str(round(alignment_data.get('end_station', 0), 3))\r\n\r\n        # Station data\r\n        self.add_stations_to_xml(alignment_data.get('stations', []), alignment_elem)\r\n\r\n        # Elements data (detailed geometric elements from geotable)\r\n        if alignment_data.get('elements'):\r\n            self.add_elements_to_xml(alignment_data.get('elements', []), alignment_elem)\r\n\r\n        # Curve data (from extractor)\r\n        if alignment_data.get('curves'):\r\n            self.add_curves_to_xml(alignment_data.get('curves', []), alignment_elem)\r\n\r\n        # Superelevation data\r\n        if alignment_data.get('superelevation'):\r\n            self.add_superelevation_to_xml(alignment_data.get('superelevation', []), alignment_elem)\r\n    \r\n    def add_stations_to_xml(self, stations_data, parent_element):\r\n        \"\"\"Add station data to XML\"\"\"\r\n        stations_elem = ET.SubElement(parent_element, 'Stations')\r\n        stations_elem.set('count', str(len(stations_data)))\r\n\r\n        for station in stations_data:\r\n            station_elem = ET.SubElement(stations_elem, 'Station')\r\n            station_elem.set('value', str(round(station.get('station', 0), 3)))\r\n\r\n            # Add point type if available (POB, PVI, PVC, PVT, etc.)\r\n            if station.get('point_type'):\r\n                station_elem.set('type', station.get('point_type'))\r\n\r\n            # Coordinates\r\n            coords = ET.SubElement(station_elem, 'Coordinates')\r\n            ET.SubElement(coords, 'X').text = str(round(station.get('x', 0), 6))\r\n            ET.SubElement(coords, 'Y').text = str(round(station.get('y', 0), 6))\r\n            ET.SubElement(coords, 'Z').text = str(round(station.get('z', 0), 6))\r\n\r\n            # Elevation (if different from Z or explicitly provided)\r\n            if station.get('elevation') is not None:\r\n                ET.SubElement(station_elem, 'Elevation').text = str(round(station.get('elevation', 0), 2))\r\n\r\n            # Direction/Bearing\r\n            ET.SubElement(station_elem, 'Direction').text = str(round(station.get('direction', 0), 6))\r\n            ET.SubElement(station_elem, 'Offset').text = str(round(station.get('offset', 0), 3))\r\n    \r\n    def add_elements_to_xml(self, elements_data, parent_element):\r\n        \"\"\"Add detailed geometric elements from geotable to XML\"\"\"\r\n        elements_elem = ET.SubElement(parent_element, 'GeometricElements')\r\n        elements_elem.set('count', str(len(elements_data)))\r\n\r\n        for idx, element in enumerate(elements_data):\r\n            element_elem = ET.SubElement(elements_elem, 'Element')\r\n            element_elem.set('type', element.get('type', 'Unknown'))\r\n            element_elem.set('index', str(idx))\r\n\r\n            # Add element stations (POB, PVI, PVC, PVT, etc.)\r\n            if element.get('stations'):\r\n                stations_elem = ET.SubElement(element_elem, 'Stations')\r\n                for station in element.get('stations', []):\r\n                    station_elem = ET.SubElement(stations_elem, 'Station')\r\n                    station_elem.set('type', station.get('point_type', 'Unknown'))\r\n                    station_elem.set('value', str(round(station.get('station', 0), 2)))\r\n\r\n                    if station.get('elevation') is not None:\r\n                        ET.SubElement(station_elem, 'Elevation').text = str(round(station.get('elevation', 0), 2))\r\n\r\n            # Add element properties\r\n            if element.get('properties'):\r\n                props_elem = ET.SubElement(element_elem, 'ElementProperties')\r\n                for prop_name, prop_value in element.get('properties', {}).items():\r\n                    prop_elem = ET.SubElement(props_elem, 'Property')\r\n                    prop_elem.set('name', prop_name)\r\n                    prop_elem.text = str(prop_value)\r\n\r\n    def add_curves_to_xml(self, curves_data, parent_element):\r\n        \"\"\"Add curve/entity data to XML\"\"\"\r\n        curves_elem = ET.SubElement(parent_element, 'GeometricEntities')\r\n        curves_elem.set('count', str(len(curves_data)))\r\n\r\n        for curve in curves_data:\r\n            entity_elem = ET.SubElement(curves_elem, 'Entity')\r\n            entity_elem.set('type', curve.get('type', 'Unknown'))\r\n            entity_elem.set('index', str(curve.get('index', 0)))\r\n\r\n            # Common properties\r\n            ET.SubElement(entity_elem, 'StartStation').text = str(round(curve.get('start_station', 0), 3))\r\n            ET.SubElement(entity_elem, 'EndStation').text = str(round(curve.get('end_station', 0), 3))\r\n            ET.SubElement(entity_elem, 'Length').text = str(round(curve.get('length', 0), 3))\r\n\r\n            # Type-specific properties\r\n            if curve.get('type') == 'Arc':\r\n                arc_props = ET.SubElement(entity_elem, 'ArcProperties')\r\n                ET.SubElement(arc_props, 'Radius').text = str(round(curve.get('radius', 0), 3))\r\n                ET.SubElement(arc_props, 'ChordLength').text = str(round(curve.get('chord_length', 0), 3))\r\n                ET.SubElement(arc_props, 'Direction').text = curve.get('direction', 'CW')\r\n\r\n            elif curve.get('type') == 'Spiral':\r\n                spiral_props = ET.SubElement(entity_elem, 'SpiralProperties')\r\n                ET.SubElement(spiral_props, 'RadiusIn').text = str(round(curve.get('radius_in', 0), 3))\r\n                ET.SubElement(spiral_props, 'RadiusOut').text = str(round(curve.get('radius_out', 0), 3))\r\n                ET.SubElement(spiral_props, 'SpiralType').text = curve.get('spiral_type', 'Unknown')\r\n\r\n            elif curve.get('type') == 'Line':\r\n                line_props = ET.SubElement(entity_elem, 'LineProperties')\r\n                ET.SubElement(line_props, 'Bearing').text = str(round(curve.get('bearing', 0), 6))\r\n    \r\n    def add_superelevation_to_xml(self, superelevation_data, parent_element):\r\n        \"\"\"Add superelevation data to XML\"\"\"\r\n        se_elem = ET.SubElement(parent_element, 'Superelevation')\r\n        se_elem.set('count', str(len(superelevation_data)))\r\n        \r\n        for se in superelevation_data:\r\n            critical_elem = ET.SubElement(se_elem, 'CriticalStation')\r\n            critical_elem.set('station', str(round(se.get('station', 0), 3)))\r\n            \r\n            ET.SubElement(critical_elem, 'TransitionType').text = se.get('type', 'Unknown')\r\n            ET.SubElement(critical_elem, 'LeftSlope').text = str(round(se.get('left_slope', 0), 4))\r\n            ET.SubElement(critical_elem, 'RightSlope').text = str(round(se.get('right_slope', 0), 4))\r\n    \r\n    def generate_xml(self):\r\n        \"\"\"Generate complete XML structure\"\"\"\r\n        alignments_section = self.create_xml_structure()\r\n        \r\n        # Add each alignment\r\n        for alignment in self.data.get('alignments', []):\r\n            self.add_alignment_to_xml(alignment, alignments_section)\r\n        \r\n        return self.root\r\n    \r\n    def to_xml_string(self, pretty_print=True):\r\n        \"\"\"Convert to XML string\"\"\"\r\n        xml_root = self.generate_xml()\r\n        \r\n        if pretty_print:\r\n            # Pretty print with proper indentation\r\n            rough_string = ET.tostring(xml_root, encoding='utf-8')\r\n            reparsed = minidom.parseString(rough_string)\r\n            return reparsed.toprettyxml(indent=\"  \", encoding='utf-8').decode('utf-8')\r\n        else:\r\n            return ET.tostring(xml_root, encoding='utf-8').decode('utf-8')\r\n    \r\n    def save_to_file(self, file_path, pretty_print=True):\r\n        \"\"\"Save XML to file\"\"\"\r\n        xml_string = self.to_xml_string(pretty_print)\r\n        \r\n        with open(file_path, 'w', encoding='utf-8') as f:\r\n            f.write(xml_string)\r\n        \r\n        return file_path\r\n\r\n\r\n# ============= DYNAMO SCRIPT ENTRY POINT =============\r\n\r\ndef sanitize_data(obj):\r\n    \"\"\"Force convert any object to Python native types\"\"\"\r\n    if obj is None:\r\n        return None\r\n    \r\n    # Check if already a Python dict (most important check first!)\r\n    if isinstance(obj, dict):\r\n        py_dict = {}\r\n        for k, v in obj.items():\r\n            py_dict[str(k)] = sanitize_data(v)\r\n        return py_dict\r\n    \r\n    # Check if already a Python list\r\n    if isinstance(obj, list):\r\n        return [sanitize_data(item) for item in obj]\r\n    \r\n    # Check if already a Python tuple\r\n    if isinstance(obj, tuple):\r\n        return tuple(sanitize_data(item) for item in obj)\r\n    \r\n    # Handle booleans (before numbers!)\r\n    if isinstance(obj, bool):\r\n        return bool(obj)\r\n    \r\n    # Handle strings\r\n    if isinstance(obj, str):\r\n        return str(obj)\r\n    \r\n    # Handle numbers (int and float)\r\n    if isinstance(obj, (int, float)) and not isinstance(obj, bool):\r\n        try:\r\n            return float(str(obj))\r\n        except:\r\n            return obj\r\n    \r\n    # Now handle .NET dict-like objects (have both 'keys' and 'items' methods)\r\n    # Check BOTH to ensure it's really dict-like and not just iterable\r\n    if hasattr(obj, 'keys') and hasattr(obj, 'items'):\r\n        try:\r\n            if callable(getattr(obj, 'items')) and callable(getattr(obj, 'keys')):\r\n                py_dict = {}\r\n                for k, v in obj.items():\r\n                    py_dict[str(k)] = sanitize_data(v)\r\n                return py_dict\r\n        except:\r\n            pass\r\n    \r\n    # Handle .NET list-like objects (iterable but not string/dict)\r\n    # But first make sure it's NOT dict-like!\r\n    if not hasattr(obj, 'keys'):\r\n        try:\r\n            # Try to iterate\r\n            py_list = []\r\n            for item in obj:\r\n                py_list.append(sanitize_data(item))\r\n            return py_list\r\n        except (TypeError, AttributeError):\r\n            pass\r\n    \r\n    # Last resort: convert to string\r\n    return str(obj)\r\n\r\n\r\ndef convert_geotable_list_to_dict(geotable_list):\r\n    \"\"\"\r\n    Convert raw geotable list format to dictionary format\r\n\r\n    Input: List of lists like [['Name, Text'], ['Description, Text'], ...]\r\n    Output: Dictionary structure compatible with XMLReportGenerator\r\n    \"\"\"\r\n    result = {\r\n        'project_name': 'Civil 3D Geotable Export',\r\n        'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),\r\n        'alignments': []\r\n    }\r\n\r\n    # Check if this is a list of geotables (multiple alignments)\r\n    if isinstance(geotable_list, list) and len(geotable_list) > 0:\r\n\r\n        # Case 1: Single geotable (list of rows)\r\n        if isinstance(geotable_list[0], list) and len(geotable_list[0]) == 2:\r\n            # This is a single geotable with rows like ['Property', 'Value']\r\n            alignment_dict = parse_geotable_rows(geotable_list)\r\n            if alignment_dict:\r\n                result['alignments'].append(alignment_dict)\r\n\r\n        # Case 2: Multiple geotables (list of geotables)\r\n        else:\r\n            for item in geotable_list:\r\n                if isinstance(item, list):\r\n                    alignment_dict = parse_geotable_rows(item)\r\n                    if alignment_dict:\r\n                        result['alignments'].append(alignment_dict)\r\n\r\n    return result\r\n\r\n\r\ndef parse_station_value(station_str):\r\n    \"\"\"\r\n    Convert Civil 3D station format to float\r\n    Examples: \"641+44.67\" -> 64144.67, \"100.50\" -> 100.50\r\n    \"\"\"\r\n    try:\r\n        station_str = str(station_str).strip()\r\n        if '+' in station_str:\r\n            # Format: \"641+44.67\"\r\n            parts = station_str.split('+')\r\n            if len(parts) == 2:\r\n                return float(parts[0]) * 100 + float(parts[1])\r\n        # Direct numeric value\r\n        return float(station_str)\r\n    except:\r\n        return 0.0\r\n\r\n\r\ndef parse_geotable_rows(rows):\r\n    \"\"\"\r\n    Parse geotable rows into alignment dictionary\r\n\r\n    Input: List of [property, value] pairs from Civil 3D geotable\r\n    Output: Alignment dictionary with detailed geometric data\r\n    \"\"\"\r\n    alignment = {\r\n        'name': 'Unknown',\r\n        'id': '',\r\n        'description': '',\r\n        'length': 0.0,\r\n        'start_station': 0.0,\r\n        'end_station': 0.0,\r\n        'project_name': '',\r\n        'horizontal_alignment': '',\r\n        'vertical_alignment': '',\r\n        'style': '',\r\n        'stations': [],\r\n        'curves': [],\r\n        'elements': [],\r\n        'superelevation': []\r\n    }\r\n\r\n    current_element = None\r\n    current_element_type = None\r\n    station_data = []\r\n\r\n    for i, row in enumerate(rows):\r\n        if not isinstance(row, list) or len(row) < 2:\r\n            continue\r\n\r\n        # Get property name and value\r\n        prop_name = str(row[0]).strip()\r\n        prop_value = str(row[1]).strip() if len(row) > 1 else ''\r\n\r\n        # Check if there's a third column (e.g., ELEVATION)\r\n        third_value = str(row[2]).strip() if len(row) > 2 else ''\r\n\r\n        prop_name_lower = prop_name.lower()\r\n\r\n        # Skip header rows\r\n        if prop_name_lower == '' and prop_value.upper() == 'STATION':\r\n            continue\r\n\r\n        # Project-level properties\r\n        if 'project name' in prop_name_lower:\r\n            alignment['project_name'] = prop_value\r\n        elif 'horizontal alignment name' in prop_name_lower:\r\n            alignment['horizontal_alignment'] = prop_value\r\n            if not alignment['name'] or alignment['name'] == 'Unknown':\r\n                alignment['name'] = prop_value\r\n        elif 'vertical alignment name' in prop_name_lower:\r\n            alignment['vertical_alignment'] = prop_value\r\n        elif prop_name_lower == 'style':\r\n            alignment['style'] = prop_value\r\n        elif prop_name_lower == 'description':\r\n            alignment['description'] = prop_value\r\n\r\n        # Element headers (Linear, Parabola, Spiral, etc.)\r\n        elif prop_name_lower.startswith('element:'):\r\n            # Save previous element if exists\r\n            if current_element is not None:\r\n                alignment['elements'].append(current_element)\r\n\r\n            # Start new element\r\n            element_type = prop_name.split(':')[1].strip()\r\n            current_element_type = element_type\r\n            current_element = {\r\n                'type': element_type,\r\n                'properties': {},\r\n                'stations': []\r\n            }\r\n\r\n        # Station points with elevation (POB, PVI, PVC, PVT, etc.)\r\n        elif prop_value and third_value and current_element is not None:\r\n            # Try to parse as station+elevation pair\r\n            station_val = parse_station_value(prop_value)\r\n            try:\r\n                elevation_val = float(third_value)\r\n\r\n                if station_val > 0 or elevation_val != 0:\r\n                    current_element['stations'].append({\r\n                        'point_type': prop_name,\r\n                        'station': station_val,\r\n                        'elevation': elevation_val\r\n                    })\r\n\r\n                    # Also track for overall alignment\r\n                    station_data.append({\r\n                        'station': station_val,\r\n                        'elevation': elevation_val,\r\n                        'point_type': prop_name,\r\n                        'x': 0.0,\r\n                        'y': 0.0,\r\n                        'z': elevation_val,\r\n                        'direction': 0.0,\r\n                        'offset': 0.0\r\n                    })\r\n                else:\r\n                    # Not a valid station/elevation, treat as property\r\n                    if current_element is not None:\r\n                        current_element['properties'][prop_name] = prop_value\r\n            except ValueError:\r\n                # Not a numeric elevation, treat as property\r\n                if current_element is not None:\r\n                    current_element['properties'][prop_name] = prop_value\r\n\r\n        # Element properties\r\n        elif current_element is not None and prop_value and prop_name:\r\n            current_element['properties'][prop_name] = prop_value\r\n\r\n        # Fallback: generic property mapping\r\n        elif 'length' in prop_name_lower and current_element is None:\r\n            try:\r\n                alignment['length'] = float(prop_value)\r\n            except:\r\n                pass\r\n        elif 'start' in prop_name_lower and 'station' in prop_name_lower:\r\n            try:\r\n                alignment['start_station'] = parse_station_value(prop_value)\r\n            except:\r\n                pass\r\n        elif 'end' in prop_name_lower and 'station' in prop_name_lower:\r\n            try:\r\n                alignment['end_station'] = parse_station_value(prop_value)\r\n            except:\r\n                pass\r\n        elif 'id' in prop_name_lower:\r\n            alignment['id'] = prop_value\r\n\r\n    # Save last element\r\n    if current_element is not None:\r\n        alignment['elements'].append(current_element)\r\n\r\n    # Add collected station data\r\n    alignment['stations'] = station_data\r\n\r\n    # Calculate start/end stations if not set\r\n    if station_data:\r\n        if alignment['start_station'] == 0.0:\r\n            alignment['start_station'] = min(s['station'] for s in station_data)\r\n        if alignment['end_station'] == 0.0:\r\n            alignment['end_station'] = max(s['station'] for s in station_data)\r\n\r\n    return alignment\r\n\r\n\r\ndef main(geotable_data, output_path=None, pretty_print=True):\r\n    \"\"\"\r\n    Main function called by Dynamo\r\n\r\n    Inputs (IN[0], IN[1], IN[2]):\r\n    - geotable_data: Dictionary or List - Output from civil3d_geotable_extractor.py or raw geotable\r\n    - output_path: String - File path to save XML (optional, None for string output)\r\n    - pretty_print: Boolean - Whether to format XML with indentation\r\n\r\n    Output (OUT):\r\n    - XML string or file path (if saved)\r\n    \"\"\"\r\n    try:\r\n        # Validate input type\r\n        if geotable_data is None:\r\n            return \"Error: No data received from extractor\"\r\n\r\n        # DEBUG: Show what we received\r\n        debug_info = []\r\n        debug_info.append(f\"Received type: {type(geotable_data)}\")\r\n        debug_info.append(f\"Type string: {str(type(geotable_data))}\")\r\n\r\n        # Handle error input\r\n        if isinstance(geotable_data, str):\r\n            if geotable_data.startswith(\"Error\"):\r\n                return geotable_data\r\n            else:\r\n                return \"Error: Received string instead of data dictionary: \" + str(geotable_data)[:500]\r\n\r\n        # CRITICAL: Sanitize data again here in case Dynamo converted it during transfer\r\n        geotable_data = sanitize_data(geotable_data)\r\n\r\n        debug_info.append(f\"After sanitization type: {type(geotable_data)}\")\r\n\r\n        # Convert list format to dictionary if needed\r\n        if isinstance(geotable_data, list):\r\n            debug_info.append(\"Converting list format to dictionary structure...\")\r\n            geotable_data = convert_geotable_list_to_dict(geotable_data)\r\n            debug_info.append(f\"After conversion - Alignments count: {len(geotable_data.get('alignments', []))}\")\r\n\r\n        # Verify it's a dictionary\r\n        if not isinstance(geotable_data, dict):\r\n            return \"Error: Expected dictionary but received: \" + str(type(geotable_data)) + \"\\n\" + \"\\n\".join(debug_info)\r\n\r\n        # Check if dictionary has required keys\r\n        if 'alignments' not in geotable_data:\r\n            return \"Error: Data missing 'alignments' key. Keys found: \" + str(list(geotable_data.keys())) + \"\\n\" + \"\\n\".join(debug_info)\r\n\r\n        # DEBUG: Check alignments type\r\n        alignments = geotable_data.get('alignments', [])\r\n        debug_info.append(f\"Alignments type: {type(alignments)}\")\r\n        debug_info.append(f\"Alignments count: {len(alignments) if hasattr(alignments, '__len__') else 'N/A'}\")\r\n\r\n        if len(alignments) > 0:\r\n            first_alignment = alignments[0]\r\n            debug_info.append(f\"First alignment type: {type(first_alignment)}\")\r\n\r\n            # Additional check - if alignments still contain lists, try to convert them\r\n            if isinstance(first_alignment, list):\r\n                debug_info.append(\"WARNING: Alignments still in list format after conversion. Attempting individual conversion...\")\r\n                converted_alignments = []\r\n                for idx, alignment in enumerate(alignments):\r\n                    if isinstance(alignment, list):\r\n                        converted = parse_geotable_rows(alignment)\r\n                        converted_alignments.append(converted)\r\n                        if idx == 0:\r\n                            debug_info.append(f\"First converted alignment: {str(converted)[:200]}\")\r\n                    else:\r\n                        converted_alignments.append(alignment)\r\n                geotable_data['alignments'] = converted_alignments\r\n                debug_info.append(f\"Converted {len(converted_alignments)} alignments from list to dict format\")\r\n            else:\r\n                debug_info.append(f\"First alignment value (first 200 chars): {str(first_alignment)[:200]}\")\r\n\r\n        # Generate XML\r\n        generator = XMLReportGenerator(geotable_data)\r\n\r\n        if output_path and output_path != \"\":\r\n            # Save to file\r\n            result_path = generator.save_to_file(output_path, pretty_print)\r\n            return \"XML report saved to: \" + result_path\r\n        else:\r\n            # Return XML string\r\n            return generator.to_xml_string(pretty_print)\r\n\r\n    except Exception as e:\r\n        import traceback\r\n        error_msg = \"Error generating XML: \" + str(e) + \"\\n\" + traceback.format_exc()\r\n        if 'debug_info' in locals():\r\n            error_msg += \"\\n\\nDEBUG INFO:\\n\" + \"\\n\".join(debug_info)\r\n        return error_msg\r\n\r\n\r\n# Check if running in Dynamo context\r\nif 'IN' in dir():\r\n    # Get inputs from Dynamo\r\n    geotable_data = IN[0] if len(IN) > 0 else {}\r\n    output_path = IN[1] if len(IN) > 1 and IN[1] != \"\" else None\r\n    pretty_print = IN[2] if len(IN) > 2 else True\r\n    \r\n    # Execute and return output\r\n    OUT = main(geotable_data, output_path, pretty_print)\r\nelse:\r\n    # Standalone execution for testing\r\n    OUT = \"Script loaded successfully. Use in Dynamo context.\"\r\n\r\n",
      "Engine": "CPython3",
      "VariableInputPorts": true,
      "Id": "d867be93786542268cfe29f2bd1b08b0",
      "NodeType": "PythonScriptNode",
      "Inputs": [
        {
          "Id": "2fae8d6168cd48d39fdd3e3d093b736c",
          "Name": "IN[0]",
          "Description": "Input #0",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        },
        {
          "Id": "f657cc51cb04439f9bc77581b3353282",
          "Name": "IN[1]",
          "Description": "Input #1",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        },
        {
          "Id": "c5535f09e88e42328eff0b94d832d246",
          "Name": "IN[2]",
          "Description": "Input #2",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        }
      ],
      "Outputs": [
        {
          "Id": "82cae275b0df4c12a9f477cf0dca088c",
          "Name": "OUT",
          "Description": "Result of the python script",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        }
      ],
      "Replication": "Disabled",
      "Description": "Runs an embedded Python script."
    },
    {
      "ConcreteType": "PythonNodeModels.PythonNode, PythonNodeModels",
      "Code": "\"\"\"\r\nCivil 3D Rail Alignment Geotable Data Extractor for Dynamo\r\nThis script extracts rail alignment geotable data from Civil 3D documents\r\nand prepares it for XML report generation.\r\n\r\nUsage in Dynamo:\r\n- Import this script as a Python Script node\r\n- Connect Civil 3D document and alignment inputs\r\n- Outputs structured data ready for XML formatting\r\n\"\"\"\r\n\r\nimport clr\r\nimport sys\r\n\r\n# Add Civil 3D API references - only essential ones for Dynamo\r\ntry:\r\n    clr.AddReference('AeccDbMgd')\r\n    clr.AddReference('AcMgd')\r\n    clr.AddReference('AcCoreMgd')\r\n    clr.AddReference('AcDbMgd')\r\nexcept:\r\n    pass  # Some references may already be loaded\r\n\r\n# Import Civil 3D namespaces\r\nfrom Autodesk.Civil.ApplicationServices import *\r\nfrom Autodesk.Civil.DatabaseServices import *\r\nfrom Autodesk.AutoCAD.ApplicationServices import Application\r\nfrom Autodesk.AutoCAD.DatabaseServices import *\r\nfrom Autodesk.AutoCAD.Geometry import *\r\nfrom System.Collections.Generic import List\r\nfrom System import *\r\n\r\n# Import Reference for out parameters\r\ntry:\r\n    from clr import Reference\r\nexcept:\r\n    Reference = None  # Fallback if not available\r\n\r\n\r\nclass GeoTableDataExtractor:\r\n    \"\"\"Extract geotable data from Civil 3D rail alignments\"\"\"\r\n    \r\n    def __init__(self, document=None):\r\n        \"\"\"Initialize the extractor with Civil 3D document\"\"\"\r\n        if document is None:\r\n            self.civil_doc = CivilApplication.ActiveDocument\r\n        else:\r\n            self.civil_doc = document\r\n        \r\n        self.acad_doc = Application.DocumentManager.MdiActiveDocument\r\n        self.db = self.acad_doc.Database\r\n        \r\n    def get_all_alignments(self):\r\n        \"\"\"Get all alignments from the Civil 3D document\"\"\"\r\n        alignments = []\r\n        \r\n        try:\r\n            trans = self.db.TransactionManager.StartTransaction()\r\n            \r\n            # Get alignment collection\r\n            alignment_ids = self.civil_doc.GetAlignmentIds()\r\n            \r\n            for oid in alignment_ids:\r\n                alignment = trans.GetObject(oid, OpenMode.ForRead)\r\n                \r\n                # Safely get properties with fallbacks and convert to Python types\r\n                try:\r\n                    start_station = float(alignment.StartingStation)\r\n                except:\r\n                    start_station = 0.0\r\n                \r\n                try:\r\n                    end_station = float(alignment.EndingStation)\r\n                except:\r\n                    try:\r\n                        end_station = float(alignment.Length) if hasattr(alignment, 'Length') else 0.0\r\n                    except:\r\n                        end_station = 0.0\r\n                \r\n                # Convert all .NET types to Python types\r\n                alignments.append({\r\n                    'id': str(oid),\r\n                    'name': str(alignment.Name) if hasattr(alignment, 'Name') else 'Unknown',\r\n                    'description': str(alignment.Description) if hasattr(alignment, 'Description') else '',\r\n                    'length': float(alignment.Length) if hasattr(alignment, 'Length') else 0.0,\r\n                    'start_station': start_station,\r\n                    'end_station': end_station,\r\n                    'object': alignment\r\n                })\r\n            \r\n            trans.Commit()\r\n            trans.Dispose()\r\n            \r\n        except Exception as e:\r\n            if trans:\r\n                trans.Abort()\r\n                trans.Dispose()\r\n            raise Exception(\"Error retrieving alignments: \" + str(e))\r\n        \r\n        return alignments\r\n    \r\n    def extract_alignment_stations(self, alignment, interval=None):\r\n        \"\"\"Extract station data along an alignment\"\"\"\r\n        stations_data = []\r\n        \r\n        if interval is None:\r\n            interval = 10.0  # Default 10 unit interval\r\n        \r\n        try:\r\n            start_station = float(str(alignment.StartingStation))\r\n            end_station = float(str(alignment.EndingStation))\r\n            current_station = start_station\r\n            \r\n            # Sample stations along the alignment\r\n            while current_station <= end_station:\r\n                try:\r\n                    # Create a simple station entry with Python native types\r\n                    station_data = {\r\n                        'station': float(str(current_station)),\r\n                        'x': 0.0,  # Will try to get actual coordinates\r\n                        'y': 0.0,\r\n                        'z': 0.0,\r\n                        'direction': 0.0,\r\n                        'offset': 0.0\r\n                    }\r\n                    \r\n                    # Try to get actual point coordinates using different methods\r\n                    try:\r\n                        # Method 1: Try GetStationOffsetElevationAtXY (inverse might exist)\r\n                        # Actually, let's use the polyline representation\r\n                        polyline = alignment.GetPolyline()\r\n                        if polyline:\r\n                            # Get a point along the polyline\r\n                            # This is approximate but will work\r\n                            param = float(str((current_station - start_station) / (end_station - start_station)))\r\n                            point = polyline.GetPointAtParameter(param * float(str(polyline.EndParam)))\r\n                            station_data['x'] = float(str(point.X))\r\n                            station_data['y'] = float(str(point.Y))\r\n                            station_data['z'] = float(str(point.Z))\r\n                    except:\r\n                        # If we can't get coordinates, at least record the station\r\n                        pass\r\n                    \r\n                    stations_data.append(station_data)\r\n                    \r\n                except Exception as e:\r\n                    # Skip problematic stations\r\n                    pass\r\n                \r\n                current_station += interval\r\n            \r\n            # Always include end station\r\n            if len(stations_data) > 0 and abs(stations_data[-1]['station'] - float(str(end_station))) > 0.001:\r\n                try:\r\n                    station_data = {\r\n                        'station': float(str(end_station)),\r\n                        'x': 0.0,\r\n                        'y': 0.0,\r\n                        'z': 0.0,\r\n                        'direction': 0.0,\r\n                        'offset': 0.0\r\n                    }\r\n                    \r\n                    try:\r\n                        polyline = alignment.GetPolyline()\r\n                        if polyline:\r\n                            point = polyline.EndPoint\r\n                            station_data['x'] = float(str(point.X))\r\n                            station_data['y'] = float(str(point.Y))\r\n                            station_data['z'] = float(str(point.Z))\r\n                    except:\r\n                        pass\r\n                    \r\n                    stations_data.append(station_data)\r\n                except:\r\n                    pass\r\n                    \r\n        except Exception as e:\r\n            # Return what we have even if there's an error\r\n            pass\r\n        \r\n        return stations_data\r\n    \r\n    def extract_alignment_curves(self, alignment):\r\n        \"\"\"Extract curve data from alignment entities\"\"\"\r\n        curves_data = []\r\n        \r\n        try:\r\n            # Get alignment entities (tangents, curves, spirals)\r\n            entities = alignment.Entities\r\n            \r\n            # Use Python-style iteration instead of .NET Item indexing\r\n            entity_index = 0\r\n            for entity in entities:\r\n                try:\r\n                    # Safely get entity type\r\n                    try:\r\n                        entity_type = str(entity.EntityType)\r\n                    except:\r\n                        entity_type = 'Unknown'\r\n                    \r\n                    # Build entity data with very safe property access\r\n                    entity_data = {\r\n                        'index': entity_index,\r\n                        'type': entity_type\r\n                    }\r\n                    \r\n                    # Try to get basic properties\r\n                    try:\r\n                        entity_data['start_station'] = float(entity.StartStation)\r\n                    except:\r\n                        entity_data['start_station'] = 0.0\r\n                    \r\n                    try:\r\n                        entity_data['end_station'] = float(entity.EndStation)\r\n                    except:\r\n                        entity_data['end_station'] = 0.0\r\n                    \r\n                    try:\r\n                        entity_data['length'] = float(entity.Length)\r\n                    except:\r\n                        entity_data['length'] = 0.0\r\n                    \r\n                    # Add type-specific data with safe property access\r\n                    if 'Arc' in entity_type or 'Curve' in entity_type:\r\n                        try:\r\n                            entity_data['radius'] = float(entity.Radius)\r\n                        except:\r\n                            entity_data['radius'] = 0.0\r\n                        try:\r\n                            entity_data['chord_length'] = float(entity.ChordLength)\r\n                        except:\r\n                            entity_data['chord_length'] = 0.0\r\n                        try:\r\n                            entity_data['direction'] = 'CW' if entity.Clockwise else 'CCW'\r\n                        except:\r\n                            entity_data['direction'] = 'Unknown'\r\n                        \r\n                    elif 'Spiral' in entity_type:\r\n                        try:\r\n                            entity_data['radius_in'] = float(entity.RadiusIn)\r\n                        except:\r\n                            entity_data['radius_in'] = 0.0\r\n                        try:\r\n                            entity_data['radius_out'] = float(entity.RadiusOut)\r\n                        except:\r\n                            entity_data['radius_out'] = 0.0\r\n                        try:\r\n                            entity_data['spiral_type'] = str(entity.SpiralDefinition)\r\n                        except:\r\n                            entity_data['spiral_type'] = 'Unknown'\r\n                        \r\n                    elif 'Tangent' in entity_type or 'Line' in entity_type:\r\n                        try:\r\n                            entity_data['bearing'] = float(entity.Direction)\r\n                        except:\r\n                            entity_data['bearing'] = 0.0\r\n                    \r\n                    curves_data.append(entity_data)\r\n                    entity_index += 1\r\n                    \r\n                except Exception as e:\r\n                    # Skip problematic entities but continue\r\n                    entity_index += 1\r\n                    pass\r\n                \r\n        except Exception as e:\r\n            # Return what we have even if there's an error\r\n            pass\r\n        \r\n        return curves_data\r\n    \r\n    def extract_superelevation_data(self, alignment):\r\n        \"\"\"Extract superelevation data if available\"\"\"\r\n        superelevation_data = []\r\n        \r\n        try:\r\n            if hasattr(alignment, 'SuperelevationData') and alignment.SuperelevationData is not None:\r\n                se_data = alignment.SuperelevationData\r\n                \r\n                # Extract critical stations if they exist\r\n                if hasattr(se_data, 'CriticalStations'):\r\n                    for critical_station in se_data.CriticalStations:\r\n                        try:\r\n                            superelevation_data.append({\r\n                                'station': getattr(critical_station, 'Station', 0.0),\r\n                                'type': critical_station.TransitionType.ToString() if hasattr(critical_station, 'TransitionType') else 'Unknown',\r\n                                'left_slope': getattr(critical_station, 'LeftOutsideSlope', 0.0),\r\n                                'right_slope': getattr(critical_station, 'RightOutsideSlope', 0.0)\r\n                            })\r\n                        except:\r\n                            # Skip problematic critical stations\r\n                            pass\r\n        except:\r\n            # Superelevation might not be available - this is fine\r\n            pass\r\n        \r\n        return superelevation_data\r\n    \r\n    def extract_geotable_data(self, alignment_name=None, station_interval=10.0):\r\n        \"\"\"\r\n        Main method to extract complete geotable data for an alignment\r\n        \r\n        Parameters:\r\n        - alignment_name: Name of specific alignment (None for all alignments)\r\n        - station_interval: Interval for station sampling\r\n        \r\n        Returns:\r\n        - Dictionary containing all geotable data\r\n        \"\"\"\r\n        geotable_data = {\r\n            'project_name': str(self.acad_doc.Name),\r\n            'timestamp': str(DateTime.Now.ToString(\"yyyy-MM-dd HH:mm:ss\")),\r\n            'alignments': []\r\n        }\r\n        \r\n        alignments = self.get_all_alignments()\r\n        \r\n        # Filter by name if specified\r\n        if alignment_name:\r\n            alignments = [a for a in alignments if a['name'] == alignment_name]\r\n        \r\n        for alignment_info in alignments:\r\n            alignment_obj = alignment_info['object']\r\n            \r\n            # Convert all .NET types to Python types explicitly\r\n            # DON'T include the 'object' itself - it's a .NET object that can't be serialized\r\n            alignment_data = {\r\n                'name': str(alignment_info['name']),\r\n                'description': str(alignment_info['description']),\r\n                'id': str(alignment_info['id']),\r\n                'length': float(alignment_info['length']),\r\n                'start_station': float(alignment_info['start_station']),\r\n                'end_station': float(alignment_info['end_station']),\r\n                'stations': self.extract_alignment_stations(alignment_obj, station_interval),\r\n                'curves': self.extract_alignment_curves(alignment_obj),\r\n                'superelevation': self.extract_superelevation_data(alignment_obj)\r\n            }\r\n            \r\n            # Note: we don't include alignment_info['object'] because it's a .NET object\r\n            \r\n            geotable_data['alignments'].append(alignment_data)\r\n        \r\n        return geotable_data\r\n\r\n\r\n# ============= DYNAMO SCRIPT ENTRY POINT =============\r\n# The code below this line is executed when run in Dynamo\r\n\r\ndef sanitize_for_python(obj):\r\n    \"\"\"Recursively convert all .NET types to Python native types\"\"\"\r\n    if obj is None:\r\n        return None\r\n    \r\n    # Check if already a Python dict (most important check first!)\r\n    if isinstance(obj, dict):\r\n        py_dict = {}\r\n        for k, v in obj.items():\r\n            py_dict[str(k)] = sanitize_for_python(v)\r\n        return py_dict\r\n    \r\n    # Check if already a Python list\r\n    if isinstance(obj, list):\r\n        return [sanitize_for_python(item) for item in obj]\r\n    \r\n    # Check if already a Python tuple\r\n    if isinstance(obj, tuple):\r\n        return tuple(sanitize_for_python(item) for item in obj)\r\n    \r\n    # Handle booleans (before numbers!)\r\n    if isinstance(obj, bool):\r\n        return bool(obj)\r\n    \r\n    # Handle strings\r\n    if isinstance(obj, str):\r\n        return str(obj)\r\n    \r\n    # Handle numbers (int and float)\r\n    if isinstance(obj, (int, float)) and not isinstance(obj, bool):\r\n        try:\r\n            return float(str(obj))\r\n        except:\r\n            return obj\r\n    \r\n    # Now handle .NET dict-like objects (have both 'keys' and 'items' methods)\r\n    # Check BOTH to ensure it's really dict-like and not just iterable\r\n    if hasattr(obj, 'keys') and hasattr(obj, 'items'):\r\n        try:\r\n            if callable(getattr(obj, 'items')) and callable(getattr(obj, 'keys')):\r\n                py_dict = {}\r\n                for k, v in obj.items():\r\n                    py_dict[str(k)] = sanitize_for_python(v)\r\n                return py_dict\r\n        except:\r\n            pass\r\n    \r\n    # Handle .NET list-like objects (iterable but not string/dict)\r\n    # But first make sure it's NOT dict-like!\r\n    if not hasattr(obj, 'keys'):\r\n        try:\r\n            # Try to iterate\r\n            py_list = []\r\n            for item in obj:\r\n                py_list.append(sanitize_for_python(item))\r\n            return py_list\r\n        except (TypeError, AttributeError):\r\n            pass\r\n    \r\n    # Last resort: convert to string\r\n    return str(obj)\r\n\r\n\r\ndef main(alignment_name=None, station_interval=10.0):\r\n    \"\"\"\r\n    Main function called by Dynamo\r\n    \r\n    Inputs (IN[0], IN[1]):\r\n    - alignment_name: String - Name of alignment to extract (None for all)\r\n    - station_interval: Float - Station sampling interval in drawing units\r\n    \r\n    Output (OUT):\r\n    - Dictionary containing all extracted geotable data\r\n    \"\"\"\r\n    try:\r\n        extractor = GeoTableDataExtractor()\r\n        result = extractor.extract_geotable_data(alignment_name, station_interval)\r\n        \r\n        # Recursively sanitize all data to pure Python types\r\n        sanitized_result = sanitize_for_python(result)\r\n        \r\n        return sanitized_result\r\n        \r\n    except Exception as e:\r\n        return \"Error: \" + str(e)\r\n\r\n\r\n# Check if running in Dynamo context\r\nif 'IN' in dir():\r\n    # Get inputs from Dynamo\r\n    alignment_name = IN[0] if len(IN) > 0 and IN[0] != \"\" else None\r\n    station_interval = IN[1] if len(IN) > 1 else 10.0\r\n    \r\n    # Execute and return output\r\n    OUT = main(alignment_name, station_interval)\r\nelse:\r\n    # Standalone execution for testing\r\n    OUT = \"Script loaded successfully. Use in Dynamo context.\"\r\n\r\n",
      "Engine": "CPython3",
      "VariableInputPorts": true,
      "Id": "c541d3b3d7fc428cbd9c98162d608c31",
      "NodeType": "PythonScriptNode",
      "Inputs": [
        {
          "Id": "156e27edf3a7465b80b2ce33d4ab2f26",
          "Name": "IN[0]",
          "Description": "Input #0",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        }
      ],
      "Outputs": [
        {
          "Id": "97a783c8e2cd47ebac5aafeb9e80b5c7",
          "Name": "OUT",
          "Description": "Result of the python script",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        }
      ],
      "Replication": "Disabled",
      "Description": "Runs an embedded Python script."
    },
    {
      "ConcreteType": "CoreNodeModels.Watch, CoreNodeModels",
      "WatchWidth": 420.0,
      "WatchHeight": 200.0,
      "Id": "dc6775f9f0894875a27d5e040cc39cee",
      "NodeType": "ExtensionNode",
      "Inputs": [
        {
          "Id": "eed5e1717138492090fdc31e57992037",
          "Name": "",
          "Description": "Node to show output from",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        }
      ],
      "Outputs": [
        {
          "Id": "066e3165b0cb460699b3fcec73462a21",
          "Name": "",
          "Description": "Node output",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        }
      ],
      "Replication": "Disabled",
      "Description": "Visualizes a node's output"
    },
    {
      "ConcreteType": "PythonNodeModels.PythonNode, PythonNodeModels",
      "Code": "\"\"\"\r\nCivil 3D GeoTable Report Generator - Portable Version\r\nGenerates PDF reports if ReportLab is available, otherwise falls back to formatted text\r\n\r\nNO INSTALLATION REQUIRED - Works with or without ReportLab\r\n\r\nUsage in Dynamo:\r\n- IN[0]: geotable data (list) or XML file path (string)\r\n- IN[1]: output file path (.pdf or .txt)\r\n- IN[2]: report_type: 'auto', 'vertical', or 'horizontal'\r\n- OUT: File path or error message\r\n\"\"\"\r\n\r\nfrom datetime import datetime\r\nimport xml.etree.ElementTree as ET\r\nimport os\r\n\r\n# Try to import ReportLab - if not available, will use text fallback\r\ntry:\r\n    from reportlab.lib import colors\r\n    from reportlab.lib.pagesizes import letter, landscape\r\n    from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle\r\n    from reportlab.lib.units import inch\r\n    from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer\r\n    from reportlab.lib.enums import TA_LEFT, TA_CENTER, TA_RIGHT\r\n    REPORTLAB_AVAILABLE = True\r\nexcept ImportError:\r\n    REPORTLAB_AVAILABLE = False\r\n\r\n\r\nclass GeoTableReportGenerator:\r\n    \"\"\"Generate reports in PDF (if ReportLab available) or text format\"\"\"\r\n\r\n    def __init__(self, alignment_data):\r\n        \"\"\"Initialize with parsed alignment data (dict format)\"\"\"\r\n        self.alignment = alignment_data\r\n\r\n    def generate_report(self, output_path, report_type='auto'):\r\n        \"\"\"\r\n        Generate report - automatically chooses PDF or text based on ReportLab availability\r\n\r\n        Parameters:\r\n        - output_path: Output file path (.pdf or .txt)\r\n        - report_type: 'vertical', 'horizontal', or 'auto'\r\n        \"\"\"\r\n        # Determine report type\r\n        if report_type == 'auto':\r\n            report_type = self._detect_report_type()\r\n\r\n        # Force PDF extension if ReportLab is available\r\n        if REPORTLAB_AVAILABLE and not output_path.lower().endswith('.pdf'):\r\n            output_path = output_path.rsplit('.', 1)[0] + '.pdf'\r\n\r\n        # Force TXT extension if ReportLab not available\r\n        if not REPORTLAB_AVAILABLE and not output_path.lower().endswith('.txt'):\r\n            output_path = output_path.rsplit('.', 1)[0] + '.txt'\r\n\r\n        if REPORTLAB_AVAILABLE:\r\n            return self._generate_pdf(output_path, report_type)\r\n        else:\r\n            return self._generate_text(output_path, report_type)\r\n\r\n    def _generate_pdf(self, output_path, report_type):\r\n        \"\"\"Generate PDF using ReportLab\"\"\"\r\n        if report_type == 'horizontal':\r\n            pagesize = landscape(letter)\r\n        else:\r\n            pagesize = letter\r\n\r\n        doc = SimpleDocTemplate(\r\n            output_path,\r\n            pagesize=pagesize,\r\n            rightMargin=0.5*inch,\r\n            leftMargin=0.5*inch,\r\n            topMargin=0.5*inch,\r\n            bottomMargin=0.5*inch\r\n        )\r\n\r\n        story = []\r\n        if report_type == 'vertical':\r\n            story = self._build_vertical_pdf()\r\n        else:\r\n            story = self._build_horizontal_pdf()\r\n\r\n        doc.build(story)\r\n        return output_path\r\n\r\n    def _generate_text(self, output_path, report_type):\r\n        \"\"\"Generate formatted text file (fallback when ReportLab not available)\"\"\"\r\n        lines = []\r\n\r\n        # Header\r\n        lines.append(f\"Project Name: {self.alignment.get('project_name', 'Unknown')}\")\r\n        lines.append(f\"   Description: {self.alignment.get('description', '')}\")\r\n\r\n        if self.alignment.get('horizontal_alignment'):\r\n            lines.append(f\"Horizontal Alignment Name: {self.alignment.get('horizontal_alignment')}\")\r\n            lines.append(f\"   Description:\")\r\n            lines.append(f\"        Style: {self.alignment.get('style', 'Default')}\")\r\n\r\n        if self.alignment.get('vertical_alignment'):\r\n            lines.append(f\"Vertical Alignment Name: {self.alignment.get('vertical_alignment')}\")\r\n            lines.append(f\"   Description:\")\r\n            lines.append(f\"        Style: {self.alignment.get('style', 'Default')}\")\r\n\r\n        lines.append(\"\")\r\n\r\n        # Column headers\r\n        if report_type == 'vertical':\r\n            lines.append(f\"{'':40s} {'STATION':>15s} {'ELEVATION':>15s}\")\r\n        else:\r\n            lines.append(f\"{'':40s} {'STATION':>15s} {'NORTHING':>15s} {'EASTING':>15s}\")\r\n\r\n        lines.append(\"\")\r\n\r\n        # Elements\r\n        for element in self.alignment.get('elements', []):\r\n            element_type = element.get('type', 'Unknown')\r\n            lines.append(f\"Element: {element_type}\")\r\n\r\n            # Station points\r\n            for station in element.get('stations', []):\r\n                point_type = station.get('point_type', '')\r\n                station_str = self._format_station(station.get('station', 0))\r\n\r\n                if report_type == 'vertical':\r\n                    elevation = station.get('elevation', 0)\r\n                    lines.append(f\"    {point_type:20s} {station_str:>15s} {elevation:>15.2f}\")\r\n                else:\r\n                    northing = station.get('y', 0)\r\n                    easting = station.get('x', 0)\r\n                    lines.append(f\"    {point_type:15s} ( ) {station_str:>15s} {northing:>15.4f} {easting:>15.4f}\")\r\n\r\n            # Properties\r\n            props = element.get('properties', {})\r\n            for prop_name, prop_value in props.items():\r\n                if report_type == 'horizontal' and (':' in prop_name or 'Direction' in prop_name):\r\n                    lines.append(f\"    {prop_name:25s} {prop_value}\")\r\n                else:\r\n                    lines.append(f\"    {prop_name:20s} {prop_value:>15s}\")\r\n\r\n            lines.append(\"\")\r\n\r\n        # Write to file\r\n        with open(output_path, 'w') as f:\r\n            f.write('\\n'.join(lines))\r\n\r\n        return output_path\r\n\r\n    def _build_vertical_pdf(self):\r\n        \"\"\"Build vertical alignment PDF content\"\"\"\r\n        story = []\r\n        styles = getSampleStyleSheet()\r\n\r\n        title_style = ParagraphStyle(\r\n            'CustomTitle',\r\n            parent=styles['Normal'],\r\n            fontSize=10,\r\n            leading=12,\r\n            leftIndent=0\r\n        )\r\n\r\n        # Header\r\n        story.append(Paragraph(f\"<b>Project Name:</b> {self.alignment.get('project_name', 'Unknown')}\", title_style))\r\n        story.append(Paragraph(f\"<b>   Description:</b> {self.alignment.get('description', '')}\", title_style))\r\n\r\n        if self.alignment.get('horizontal_alignment'):\r\n            story.append(Paragraph(f\"<b>Horizontal Alignment Name:</b> {self.alignment.get('horizontal_alignment')}\", title_style))\r\n            story.append(Paragraph(f\"<b>   Description:</b>\", title_style))\r\n            story.append(Paragraph(f\"<b>        Style:</b> {self.alignment.get('style', 'Default')}\", title_style))\r\n\r\n        if self.alignment.get('vertical_alignment'):\r\n            story.append(Paragraph(f\"<b>Vertical Alignment Name:</b> {self.alignment.get('vertical_alignment')}\", title_style))\r\n            story.append(Paragraph(f\"<b>   Description:</b>\", title_style))\r\n            story.append(Paragraph(f\"<b>        Style:</b> {self.alignment.get('style', 'Default')}\", title_style))\r\n\r\n        story.append(Spacer(1, 0.2*inch))\r\n\r\n        # Column headers\r\n        header_data = [['', 'STATION', 'ELEVATION']]\r\n        header_table = Table(header_data, colWidths=[3.5*inch, 1.5*inch, 1.5*inch])\r\n        header_table.setStyle(TableStyle([\r\n            ('FONT', (0, 0), (-1, -1), 'Courier-Bold', 9),\r\n            ('ALIGN', (1, 0), (-1, -1), 'RIGHT'),\r\n        ]))\r\n        story.append(header_table)\r\n        story.append(Spacer(1, 0.1*inch))\r\n\r\n        # Elements\r\n        for element in self.alignment.get('elements', []):\r\n            element_type = element.get('type', 'Unknown')\r\n            story.append(Paragraph(f\"<b>Element: {element_type}</b>\", title_style))\r\n\r\n            element_data = []\r\n            for station in element.get('stations', []):\r\n                point_type = station.get('point_type', '')\r\n                station_str = self._format_station(station.get('station', 0))\r\n                elevation = station.get('elevation', 0)\r\n                element_data.append([f\"    {point_type}\", station_str, f\"{elevation:.2f}\"])\r\n\r\n            if element_data:\r\n                station_table = Table(element_data, colWidths=[3.5*inch, 1.5*inch, 1.5*inch])\r\n                station_table.setStyle(TableStyle([\r\n                    ('FONT', (0, 0), (-1, -1), 'Courier', 8),\r\n                    ('ALIGN', (1, 0), (-1, -1), 'RIGHT'),\r\n                ]))\r\n                story.append(station_table)\r\n\r\n            props = element.get('properties', {})\r\n            prop_data = []\r\n            for prop_name, prop_value in props.items():\r\n                prop_data.append([f\"    {prop_name}\", prop_value, ''])\r\n\r\n            if prop_data:\r\n                prop_table = Table(prop_data, colWidths=[3.5*inch, 1.5*inch, 1.5*inch])\r\n                prop_table.setStyle(TableStyle([\r\n                    ('FONT', (0, 0), (-1, -1), 'Courier', 8),\r\n                    ('ALIGN', (1, 0), (-1, -1), 'RIGHT'),\r\n                ]))\r\n                story.append(prop_table)\r\n\r\n            story.append(Spacer(1, 0.15*inch))\r\n\r\n        return story\r\n\r\n    def _build_horizontal_pdf(self):\r\n        \"\"\"Build horizontal alignment PDF content\"\"\"\r\n        story = []\r\n        styles = getSampleStyleSheet()\r\n\r\n        title_style = ParagraphStyle(\r\n            'CustomTitle',\r\n            parent=styles['Normal'],\r\n            fontSize=10,\r\n            leading=12,\r\n            leftIndent=0\r\n        )\r\n\r\n        # Header\r\n        story.append(Paragraph(f\"<b>Project Name:</b> {self.alignment.get('project_name', 'Unknown')}\", title_style))\r\n        story.append(Paragraph(f\"<b>   Description:</b> {self.alignment.get('description', '')}\", title_style))\r\n        story.append(Paragraph(f\"<b>Horizontal Alignment Name:</b> {self.alignment.get('horizontal_alignment', self.alignment.get('name'))}\", title_style))\r\n        story.append(Paragraph(f\"<b>   Description:</b>\", title_style))\r\n        story.append(Paragraph(f\"<b>        Style:</b> {self.alignment.get('style', 'Default')}\", title_style))\r\n        story.append(Spacer(1, 0.2*inch))\r\n\r\n        # Column headers\r\n        header_data = [['', 'STATION', 'NORTHING', 'EASTING']]\r\n        header_table = Table(header_data, colWidths=[3*inch, 1.5*inch, 1.75*inch, 1.75*inch])\r\n        header_table.setStyle(TableStyle([\r\n            ('FONT', (0, 0), (-1, -1), 'Courier-Bold', 9),\r\n            ('ALIGN', (1, 0), (-1, -1), 'RIGHT'),\r\n        ]))\r\n        story.append(header_table)\r\n        story.append(Spacer(1, 0.1*inch))\r\n\r\n        # Elements\r\n        for element in self.alignment.get('elements', []):\r\n            element_type = element.get('type', 'Unknown')\r\n            story.append(Paragraph(f\"<b>Element: {element_type}</b>\", title_style))\r\n\r\n            element_data = []\r\n            for station in element.get('stations', []):\r\n                point_type = station.get('point_type', '')\r\n                station_str = self._format_station(station.get('station', 0))\r\n                northing = station.get('y', 0)\r\n                easting = station.get('x', 0)\r\n                element_data.append([f\"    {point_type} ( )\", station_str, f\"{northing:.4f}\", f\"{easting:.4f}\"])\r\n\r\n            if element_data:\r\n                station_table = Table(element_data, colWidths=[3*inch, 1.5*inch, 1.75*inch, 1.75*inch])\r\n                station_table.setStyle(TableStyle([\r\n                    ('FONT', (0, 0), (-1, -1), 'Courier', 8),\r\n                    ('ALIGN', (1, 0), (-1, -1), 'RIGHT'),\r\n                ]))\r\n                story.append(station_table)\r\n\r\n            props = element.get('properties', {})\r\n            prop_data = []\r\n            for prop_name, prop_value in props.items():\r\n                prop_data.append([f\"    {prop_name}\", prop_value, '', ''])\r\n\r\n            if prop_data:\r\n                prop_table = Table(prop_data, colWidths=[3*inch, 1.5*inch, 1.75*inch, 1.75*inch])\r\n                prop_table.setStyle(TableStyle([\r\n                    ('FONT', (0, 0), (-1, -1), 'Courier', 8),\r\n                    ('ALIGN', (1, 0), (1, -1), 'LEFT'),\r\n                ]))\r\n                story.append(prop_table)\r\n\r\n            story.append(Spacer(1, 0.15*inch))\r\n\r\n        return story\r\n\r\n    def _detect_report_type(self):\r\n        \"\"\"Auto-detect vertical vs horizontal report\"\"\"\r\n        has_elevations = any(\r\n            station.get('elevation') is not None\r\n            for element in self.alignment.get('elements', [])\r\n            for station in element.get('stations', [])\r\n        )\r\n\r\n        has_coordinates = any(\r\n            station.get('x', 0) != 0 or station.get('y', 0) != 0\r\n            for element in self.alignment.get('elements', [])\r\n            for station in element.get('stations', [])\r\n        )\r\n\r\n        return 'horizontal' if has_coordinates else 'vertical'\r\n\r\n    def _format_station(self, station_value):\r\n        \"\"\"Format station value to Civil 3D format\"\"\"\r\n        if station_value >= 100:\r\n            hundreds = int(station_value / 100)\r\n            remainder = station_value % 100\r\n            return f\"{hundreds}+{remainder:05.2f}\"\r\n        else:\r\n            return f\"{station_value:.2f}\"\r\n\r\n\r\n# ============= HELPER FUNCTIONS (from original scripts) =============\r\n\r\ndef parse_station_value(station_str):\r\n    \"\"\"Convert Civil 3D station format to float\"\"\"\r\n    try:\r\n        station_str = str(station_str).strip()\r\n        if '+' in station_str:\r\n            parts = station_str.split('+')\r\n            if len(parts) == 2:\r\n                return float(parts[0]) * 100 + float(parts[1])\r\n        return float(station_str)\r\n    except:\r\n        return 0.0\r\n\r\n\r\ndef parse_geotable_to_alignment(geotable_rows):\r\n    \"\"\"Parse raw geotable rows into alignment dictionary\"\"\"\r\n    alignment = {\r\n        'name': 'Unknown',\r\n        'project_name': '',\r\n        'description': '',\r\n        'horizontal_alignment': '',\r\n        'vertical_alignment': '',\r\n        'style': '',\r\n        'elements': []\r\n    }\r\n\r\n    current_element = None\r\n\r\n    for row in geotable_rows:\r\n        if not isinstance(row, list) or len(row) < 2:\r\n            continue\r\n\r\n        prop_name = str(row[0]).strip()\r\n        prop_value = str(row[1]).strip() if len(row) > 1 else ''\r\n        third_value = str(row[2]).strip() if len(row) > 2 else ''\r\n\r\n        prop_name_lower = prop_name.lower()\r\n\r\n        if prop_name_lower == '' and prop_value.upper() in ['STATION', 'NORTHING']:\r\n            continue\r\n\r\n        if 'project name' in prop_name_lower:\r\n            alignment['project_name'] = prop_value\r\n        elif 'horizontal alignment name' in prop_name_lower:\r\n            alignment['horizontal_alignment'] = prop_value\r\n            if not alignment['name'] or alignment['name'] == 'Unknown':\r\n                alignment['name'] = prop_value\r\n        elif 'vertical alignment name' in prop_name_lower:\r\n            alignment['vertical_alignment'] = prop_value\r\n        elif prop_name_lower == 'style':\r\n            alignment['style'] = prop_value\r\n        elif prop_name_lower == 'description':\r\n            alignment['description'] = prop_value\r\n        elif prop_name_lower.startswith('element:'):\r\n            if current_element is not None:\r\n                alignment['elements'].append(current_element)\r\n\r\n            element_type = prop_name.split(':')[1].strip()\r\n            current_element = {\r\n                'type': element_type,\r\n                'stations': [],\r\n                'properties': {}\r\n            }\r\n        elif current_element is not None and prop_value:\r\n            station_val = parse_station_value(prop_value)\r\n\r\n            if station_val > 0 and third_value:\r\n                try:\r\n                    numeric_third = float(third_value)\r\n                    current_element['stations'].append({\r\n                        'point_type': prop_name,\r\n                        'station': station_val,\r\n                        'elevation': numeric_third,\r\n                        'x': 0.0,\r\n                        'y': 0.0\r\n                    })\r\n                except ValueError:\r\n                    current_element['properties'][prop_name] = prop_value\r\n            else:\r\n                current_element['properties'][prop_name] = prop_value\r\n\r\n    if current_element is not None:\r\n        alignment['elements'].append(current_element)\r\n\r\n    return alignment\r\n\r\n\r\ndef parse_xml_to_alignment(xml_path):\r\n    \"\"\"Parse XML file to alignment dictionary\"\"\"\r\n    tree = ET.parse(xml_path)\r\n    root = tree.getroot()\r\n\r\n    ns = {'geo': 'http://civil3d.autodesk.com/geotable'}\r\n\r\n    project_info = root.find('.//geo:ProjectInfo', ns) or root.find('.//ProjectInfo')\r\n    project_name = ''\r\n    if project_info is not None:\r\n        proj_name_elem = project_info.find('.//geo:ProjectName', ns) or project_info.find('.//ProjectName')\r\n        if proj_name_elem is not None:\r\n            project_name = proj_name_elem.text or ''\r\n\r\n    alignment_elem = root.find('.//geo:Alignment', ns) or root.find('.//Alignment')\r\n    if alignment_elem is None:\r\n        raise ValueError(\"No alignment found in XML\")\r\n\r\n    alignment = {\r\n        'name': alignment_elem.get('name', 'Unknown'),\r\n        'project_name': project_name,\r\n        'description': '',\r\n        'horizontal_alignment': alignment_elem.get('name', ''),\r\n        'vertical_alignment': '',\r\n        'style': 'Default',\r\n        'elements': []\r\n    }\r\n\r\n    elements = alignment_elem.findall('.//geo:GeometricElement', ns) or alignment_elem.findall('.//GeometricElement')\r\n    for elem in elements:\r\n        element_type = elem.get('type', 'Unknown')\r\n        element = {\r\n            'type': element_type,\r\n            'stations': [],\r\n            'properties': {}\r\n        }\r\n\r\n        stations = elem.findall('.//geo:Station', ns) or elem.findall('.//Station')\r\n        for sta in stations:\r\n            station_val = float(sta.get('value', 0))\r\n            point_type = sta.get('pointType', '')\r\n            x = float(sta.get('x', 0))\r\n            y = float(sta.get('y', 0))\r\n            z = float(sta.get('z', 0))\r\n\r\n            element['stations'].append({\r\n                'point_type': point_type,\r\n                'station': station_val,\r\n                'elevation': z,\r\n                'x': x,\r\n                'y': y\r\n            })\r\n\r\n        props = elem.findall('.//geo:Property', ns) or elem.findall('.//Property')\r\n        for prop in props:\r\n            prop_name = prop.get('name', '')\r\n            prop_value = prop.get('value', '')\r\n            element['properties'][prop_name] = prop_value\r\n\r\n        alignment['elements'].append(element)\r\n\r\n    return alignment\r\n\r\n\r\ndef sanitize_data(obj):\r\n    \"\"\"Recursively convert .NET types to Python native types\"\"\"\r\n    if obj is None:\r\n        return None\r\n\r\n    if isinstance(obj, dict):\r\n        py_dict = {}\r\n        for k, v in obj.items():\r\n            py_dict[str(k)] = sanitize_data(v)\r\n        return py_dict\r\n\r\n    if isinstance(obj, list):\r\n        return [sanitize_data(item) for item in obj]\r\n\r\n    if isinstance(obj, tuple):\r\n        return tuple(sanitize_data(item) for item in obj)\r\n\r\n    if isinstance(obj, bool):\r\n        return bool(obj)\r\n\r\n    if isinstance(obj, str):\r\n        return str(obj)\r\n\r\n    if isinstance(obj, (int, float)) and not isinstance(obj, bool):\r\n        try:\r\n            return float(str(obj))\r\n        except:\r\n            return obj\r\n\r\n    if hasattr(obj, 'keys') and hasattr(obj, 'items'):\r\n        try:\r\n            if callable(getattr(obj, 'items')) and callable(getattr(obj, 'keys')):\r\n                py_dict = {}\r\n                for k, v in obj.items():\r\n                    py_dict[str(k)] = sanitize_data(v)\r\n                return py_dict\r\n        except:\r\n            pass\r\n\r\n    if not hasattr(obj, 'keys'):\r\n        try:\r\n            py_list = []\r\n            for item in obj:\r\n                py_list.append(sanitize_data(item))\r\n            return py_list\r\n        except (TypeError, AttributeError):\r\n            pass\r\n\r\n    return str(obj)\r\n\r\n\r\n# ============= DYNAMO ENTRY POINT =============\r\n\r\ndef main(input_data, output_path, report_type='auto'):\r\n    \"\"\"\r\n    Main function for Dynamo - Portable version\r\n\r\n    Inputs:\r\n    - IN[0]: input_data - Geotable data (list) or XML file path (string)\r\n    - IN[1]: output_path - Output file path (.pdf if ReportLab available, .txt otherwise)\r\n    - IN[2]: report_type - 'vertical', 'horizontal', or 'auto' (default)\r\n\r\n    Output:\r\n    - File path with status message\r\n    \"\"\"\r\n    try:\r\n        # Show ReportLab status\r\n        mode_msg = \"PDF mode (ReportLab available)\" if REPORTLAB_AVAILABLE else \"TEXT mode (ReportLab not available)\"\r\n\r\n        # Sanitize input\r\n        input_data = sanitize_data(input_data)\r\n\r\n        # Determine input type\r\n        if isinstance(input_data, str) and input_data.endswith('.xml'):\r\n            if not os.path.exists(input_data):\r\n                return f\"Error: XML file not found: {input_data}\"\r\n            alignment_data = parse_xml_to_alignment(input_data)\r\n\r\n        elif isinstance(input_data, list):\r\n            if len(input_data) > 0 and isinstance(input_data[0], list):\r\n                alignment_data = parse_geotable_to_alignment(input_data)\r\n            elif len(input_data) > 0 and isinstance(input_data[0], dict):\r\n                alignment_data = input_data[0]\r\n            else:\r\n                return \"Error: Invalid list format\"\r\n\r\n        elif isinstance(input_data, dict):\r\n            if 'alignments' in input_data:\r\n                alignments_list = input_data['alignments']\r\n                if len(alignments_list) == 0:\r\n                    return \"Error: No alignments in data\"\r\n                first_alignment = alignments_list[0]\r\n                if isinstance(first_alignment, list):\r\n                    alignment_data = parse_geotable_to_alignment(first_alignment)\r\n                else:\r\n                    alignment_data = first_alignment\r\n            else:\r\n                alignment_data = input_data\r\n\r\n        else:\r\n            return f\"Error: Invalid input type: {type(input_data)}\"\r\n\r\n        if not isinstance(alignment_data, dict):\r\n            return f\"Error: alignment_data is {type(alignment_data)}, expected dict\"\r\n\r\n        # Generate report\r\n        generator = GeoTableReportGenerator(alignment_data)\r\n        result_path = generator.generate_report(output_path, report_type)\r\n\r\n        # Return success message with mode info\r\n        file_type = \"PDF\" if result_path.lower().endswith('.pdf') else \"TEXT\"\r\n        return f\"{file_type} report saved to: {result_path}\\n({mode_msg})\"\r\n\r\n    except Exception as e:\r\n        import traceback\r\n        return f\"Error generating report: {str(e)}\\n{traceback.format_exc()}\"\r\n\r\n\r\n# Dynamo execution\r\nif 'IN' in dir():\r\n    input_data = IN[0] if len(IN) > 0 else []\r\n    output_path = IN[1] if len(IN) > 1 and IN[1] != \"\" else None\r\n    report_type = IN[2] if len(IN) > 2 else 'auto'\r\n\r\n    if output_path is None:\r\n        OUT = \"Error: Output file path required (IN[1])\"\r\n    else:\r\n        OUT = main(input_data, output_path, report_type)\r\nelse:\r\n    OUT = \"Portable script loaded. Works with or without ReportLab installed.\"\r\n",
      "Engine": "CPython3",
      "VariableInputPorts": true,
      "Id": "88aeefb7574345b39b611982f36b0149",
      "NodeType": "PythonScriptNode",
      "Inputs": [
        {
          "Id": "d96cfa20853047e5836a3c780c22002b",
          "Name": "IN[0]",
          "Description": "Input #0",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        },
        {
          "Id": "e41d91843df34c2a9cd2eeb576bf83b5",
          "Name": "IN[1]",
          "Description": "Input #1",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        },
        {
          "Id": "cb33b7a46b1b42c9bda0a91a1c627815",
          "Name": "IN[2]",
          "Description": "Input #2",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        }
      ],
      "Outputs": [
        {
          "Id": "5edb53c32f564b58a3a2aa4fd06c53eb",
          "Name": "OUT",
          "Description": "Result of the python script",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        }
      ],
      "Replication": "Disabled",
      "Description": "Runs an embedded Python script."
    },
    {
      "ConcreteType": "Dynamo.Graph.Nodes.CodeBlockNodeModel, DynamoCore",
      "Id": "ab1b87af70a14d5e85be6b1e9106b84a",
      "NodeType": "CodeBlockNode",
      "Inputs": [],
      "Outputs": [
        {
          "Id": "2fce9a9973294feb9789f8d71536d333",
          "Name": "",
          "Description": "Value of expression at line 1",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        }
      ],
      "Replication": "Disabled",
      "Description": "Allows for DesignScript code to be authored directly",
      "Code": "\"C:/Users/amartinez/Downloads/Organized/Code/alignment_report.pdf\";"
    },
    {
      "ConcreteType": "Dynamo.Graph.Nodes.CodeBlockNodeModel, DynamoCore",
      "Id": "de5843fac5314d448441ce5497cc97de",
      "NodeType": "CodeBlockNode",
      "Inputs": [],
      "Outputs": [
        {
          "Id": "9be065c24a254772bff949659506ec17",
          "Name": "",
          "Description": "Value of expression at line 1",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        }
      ],
      "Replication": "Disabled",
      "Description": "Allows for DesignScript code to be authored directly",
      "Code": "\"auto\";"
    }
  ],
  "Connectors": [
    {
      "Start": "8a61c5f6c48b4e8aa4360413726249cc",
      "End": "f657cc51cb04439f9bc77581b3353282",
      "Id": "dfd296e1bd614e95ac821ac2604d2480",
      "IsHidden": "False"
    },
    {
      "Start": "858985f70d4246bf98afc7c0924722d5",
      "End": "c5535f09e88e42328eff0b94d832d246",
      "Id": "b5a49f7c3ea44f33bc477ee1498ed718",
      "IsHidden": "False"
    },
    {
      "Start": "82cae275b0df4c12a9f477cf0dca088c",
      "End": "eed5e1717138492090fdc31e57992037",
      "Id": "31e15c8e4bba41a288e7d0dc1063105d",
      "IsHidden": "False"
    },
    {
      "Start": "97a783c8e2cd47ebac5aafeb9e80b5c7",
      "End": "d96cfa20853047e5836a3c780c22002b",
      "Id": "090e1c26e340420ba17ab35d62475879",
      "IsHidden": "False"
    },
    {
      "Start": "5edb53c32f564b58a3a2aa4fd06c53eb",
      "End": "2fae8d6168cd48d39fdd3e3d093b736c",
      "Id": "e82e3ce15a2f493f85860778a562acd5",
      "IsHidden": "False"
    },
    {
      "Start": "2fce9a9973294feb9789f8d71536d333",
      "End": "e41d91843df34c2a9cd2eeb576bf83b5",
      "Id": "badd826252da453aab40d3012bd05e46",
      "IsHidden": "False"
    },
    {
      "Start": "9be065c24a254772bff949659506ec17",
      "End": "cb33b7a46b1b42c9bda0a91a1c627815",
      "Id": "ecc1b4d37faf444490dccaef88ee851b",
      "IsHidden": "False"
    }
  ],
  "Dependencies": [],
  "NodeLibraryDependencies": [],
  "EnableLegacyPolyCurveBehavior": true,
  "Thumbnail": "",
  "GraphDocumentationURL": null,
  "ExtensionWorkspaceData": [
    {
      "ExtensionGuid": "28992e1d-abb9-417f-8b1b-05e053bee670",
      "Name": "Properties",
      "Version": "2.13",
      "Data": {}
    }
  ],
  "Author": "Autodesk",
  "Linting": {
    "activeLinter": "None",
    "activeLinterId": "7b75fb44-43fd-4631-a878-29f4d5d8399a",
    "warningCount": 0,
    "errorCount": 0
  },
  "Bindings": [],
  "View": {
    "Dynamo": {
      "ScaleFactor": 1.0,
      "HasRunWithoutCrash": true,
      "IsVisibleInDynamoLibrary": true,
      "Version": "3.2.2.5494",
      "RunType": "Manual",
      "RunPeriod": "1000"
    },
    "Camera": {
      "Name": "_Background Preview",
      "EyeX": -17.0,
      "EyeY": 24.0,
      "EyeZ": 50.0,
      "LookX": 12.0,
      "LookY": -13.0,
      "LookZ": -58.0,
      "UpX": 0.0,
      "UpY": 1.0,
      "UpZ": 0.0
    },
    "ConnectorPins": [],
    "NodeViews": [
      {
        "Id": "21ce6789d9fa4e6ea6760ef79280e26d",
        "Name": "Code Block",
        "IsSetAsInput": false,
        "IsSetAsOutput": false,
        "Excluded": false,
        "ShowGeometry": true,
        "X": -612.876619404127,
        "Y": 140.4686876524827
      },
      {
        "Id": "d867be93786542268cfe29f2bd1b08b0",
        "Name": "Python Script",
        "IsSetAsInput": false,
        "IsSetAsOutput": false,
        "Excluded": false,
        "ShowGeometry": true,
        "X": 333.1636389356181,
        "Y": -72.20920088032392
      },
      {
        "Id": "c541d3b3d7fc428cbd9c98162d608c31",
        "Name": "Data Extractor from Civil 3D Project",
        "IsSetAsInput": false,
        "IsSetAsOutput": false,
        "Excluded": false,
        "ShowGeometry": true,
        "X": -539.8734595047729,
        "Y": -335.172182338273
      },
      {
        "Id": "dc6775f9f0894875a27d5e040cc39cee",
        "Name": "Watch",
        "IsSetAsInput": false,
        "IsSetAsOutput": false,
        "Excluded": false,
        "ShowGeometry": true,
        "X": 613.6574858240979,
        "Y": -111.94582918952483
      },
      {
        "Id": "88aeefb7574345b39b611982f36b0149",
        "Name": "PDF Report",
        "IsSetAsInput": false,
        "IsSetAsOutput": false,
        "Excluded": false,
        "ShowGeometry": true,
        "X": 26.957856082361786,
        "Y": -221.8059192208459
      },
      {
        "Id": "ab1b87af70a14d5e85be6b1e9106b84a",
        "Name": "Code Block",
        "IsSetAsInput": false,
        "IsSetAsOutput": false,
        "Excluded": false,
        "ShowGeometry": true,
        "X": -838.0658728845775,
        "Y": -137.9094747201691
      },
      {
        "Id": "de5843fac5314d448441ce5497cc97de",
        "Name": "Code Block",
        "IsSetAsInput": false,
        "IsSetAsOutput": false,
        "Excluded": false,
        "ShowGeometry": true,
        "X": -467.06175083564506,
        "Y": -3.9876538277879945
      }
    ],
    "Annotations": [],
    "X": -121.90380987197295,
    "Y": 428.83226665560073,
    "Zoom": 1.2661690848442824
  }
}